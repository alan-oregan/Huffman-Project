---
title: "Huffman Coding Report"
format: html
author: "Alan O'Regan"
highlight-style: github
---

# Project Description
This project is an implementation of the [Huffman Coding string compression algorithm](https://en.wikipedia.org/wiki/Huffman_coding).
This implementation uses the  List and Tree abstract data types (with the addtion of the comparable interface) implemented in the **ListArrayBased** and **TreeNode** classes from the <u>Data Structures and Algorithms</u> module along with custom data classes **HuffmanSymbol** and **HuffmanEncodedSymbol** to handle the data. This implementation includes a graphical user interface to interact with the program, developed using methods from the <u>GUI Programming</u> Module.

## Part 1: Generating the Huffman Tree
In order to generate the huffman tree, the generateHuffmanTree() method uses the frequency table that was generated from the given LetterCountAscending.txt file and sorted by frequency.
- The method iterates through the frequency while there is at least 2 items remaining in the table
- On each iteration the top 2 elements are added to a new node as the left and right child nodes with the character as '*' and the frequency value as the sum of the 2 child nodes frequency values.
- The top 2 items are then removed from the frequency table and the new node is added
- The table is then sorted using the sort method added to the ListArrayBased class based on the bubble sort algorithm.
- When the iteration is complete the rootNode can be used to navigate the tree.

*Implementation: [HuffmanCoding.generateHuffmanTree Line:47](src/HuffmanCoding.java#L47)*

```java
private void generateHuffmanTree() {

    TreeNode first;
    TreeNode second;
    HuffmanSymbol newRootSymbol;
    while (frequencyTable.size() > 1) {

        // get the first two items from the table and cast them to a HuffmanSymbol
        first = (TreeNode) frequencyTable.get(1);
        second = (TreeNode) frequencyTable.get(2);

        // create the new root symbol with a '*' character
        // and the sum of the first two items frequency
        newRootSymbol = new HuffmanSymbol(
                '*',
                ((HuffmanSymbol)first.getItem()).getFrequency()
                        + ((HuffmanSymbol)second.getItem()).getFrequency()
        );

        // replace the root node with the new root symbol node
        // and use the first two items as the left and right children
        rootNode = new TreeNode(newRootSymbol);
        rootNode.setLeft(first);
        rootNode.setRight(second);

        // remove the first two items as they are now in a tree
        frequencyTable.remove(1);
        frequencyTable.remove(1);

        frequencyTable.add(frequencyTable.size()+1, rootNode); // add new root symbol to the end of the table
        frequencyTable.sort(); // sort in order to place new root symbol in its proper place
    }
}
```

## Part 2: Encode

In order to encode a given String of characters using the lookup table generated from the rootNode using a recursive post order traversal.

*Implementation: [HuffmanCoding. Line:115](src/HuffmanCoding.java#L115)*

```java
/**
 * A recursive post order traversal of the huffman tree
 * @param node the current node (first call should be the root node)
 * @param binary this parameter is used to pass the binary value throughout the tree (first call should be an empty string)
 */
private void postOrderTraverse(TreeNode node, String binary) {

    if (node == null) {
        return;
    }

    char character = ((HuffmanSymbol)node.getItem()).getCharacter();
    if (character != '*') {
        lookupTable.add(lookupTable.size()+1, new HuffmanEncodedSymbol(character, binary));
        return;
    }

    postOrderTraverse(node.getLeft(), binary+"0");
    postOrderTraverse(node.getRight(), binary+"1");
}
```


The encodeCharacters() method uses binary search to search for the binary value of each character in the string and appends it to the StringBuilder which will then be returned as the encoded value.

*Implementation: [HuffmanCoding.encodeCharacters Line:115](src/HuffmanCoding.java#L115)*

```java
/**
 * encoding method based on binary search.
 * @param characters the string of characters to be encoded
 * @return the encoded value of given characters
 */
public String encodeCharacters(String characters) {
    StringBuilder sb = new StringBuilder();
    // validate input as only capital letters from A-Z
    characters = characters.toUpperCase(Locale.ROOT).replaceAll("[^A-Z]","");

    for (char ch : characters.toCharArray()) {

        int low = 1, high = lookupTable.size(), mid;
        while (low <= high) {
            mid = (low + high) / 2;
            HuffmanEncodedSymbol midItem = ((HuffmanEncodedSymbol)lookupTable.get(mid));

            if (midItem.letter == ch) {
                sb.append(midItem.binary);
                break; // value found exit loop
            }

            if (ch > midItem.letter)
                low = mid + 1;
            else
                high = mid - 1;
        }
    }

    return sb.toString();
}
```


## Part 3: Decode

The decode implementation is handled in the decodeCharacters() method using the rootNode of the huffman tree.
Each character in the encoded string are iterated through using a enhanced for loop.
- the method intialises the current node as the root node
- if a character is 0 then the the current node is set as the let child of the current node and the right node for 1.
- if the character of the node is the not '*' then the character is added to the stringbuilder and the current node is reset to the root node.
- once the loop is finished the contents of the string builder are returned as the decoded value.

Implementation: *[HuffmanCoding.decodeCharacters() Line:147](src/HuffmanCoding.java#L147)*

```java
/**
 * Huffman Decoding implementation
 * @param characters the string of characters to be decoded
 * @return the decoded value of given characters
 */
public String decodeCharacters(String characters) {
    StringBuilder sb = new StringBuilder();
    TreeNode currentNode = rootNode;
    // validate characters as only numbers 0 and 1
    characters = characters.toUpperCase(Locale.ROOT).replaceAll("[^01]","");

    for (char ch : characters.toCharArray()) {

        char character = ((HuffmanSymbol) currentNode.getItem()).getCharacter();

        if (character != '*') {
            sb.append(character);
            currentNode = rootNode;
        }

        currentNode = switch (ch) {
            case '0' -> currentNode.getLeft();
            case '1' -> currentNode.getRight();
            default -> currentNode;
        };
    }
    if (((HuffmanSymbol) currentNode.getItem()).getCharacter() != '*')
        sb.append(((HuffmanSymbol) currentNode.getItem()).getCharacter());

    return sb.toString();
}
```

## Part 4: Program Interface

The program interface features 2 buttons for encoding and decoding, a label for user messages and an input box for encoding and decoding, the results of the encoding and decoding are also placed inside the input box.

![Screenshot of Program Interface](images/Program%20Interface%20Screenshot.jpg)

### Encode button logic

Implementation: *[HuffmanCodingGUI.actionPerformed() Line:188](src/HuffmanCodingGUI.java#L88)*

Compression Ratio Formula:
    Number of bits in input = Number of characters * 7
    (Number of bits in encoding / (Number of bits in input)) * 100

```java
if (source == encode) {

    if (!inputText.isBlank())
        result = huffmanCoding.encodeCharacters(inputText);
    else
        resultTextArea.setText("Empty Input");


    if (!result.isBlank()) {
        inputTextArea.setText(result);
        resultTextArea.setText("Encoded!");

        inputText = inputText.toUpperCase(Locale.ROOT).replaceAll("[^A-Z]","");

        if (inputText.length() > 0) {
            resultTextArea.setText(String.format("Encoded! (Compression Ratio: %.2f%%)", (((float)result.length())/(inputText.length()*7))*100));
        }
    }
}
```

### Decode button logic

Implementation: *[HuffmanCodingGUI.actionPerformed() Line:108](src/HuffmanCodingGUI.java#L108)*

```java
if (source == decode) {

    if (!inputText.isBlank())
        result = huffmanCoding.decodeCharacters(inputText);
    else
        resultTextArea.setText("Empty Input");


    if (!result.isBlank()) {
        inputTextArea.setText(result);
        resultTextArea.setText("Decoded!");
    }
}
```

# Testing

## Unit Testing

## Input Validation Testing

### Test Cases

# Academic Honesty

Any work that you submit for continuous assessment or assignments must be done by you. Failure to acknowledge the source of a significant idea or approach is considered plagiarism and not allowed.  Academic dishonesty will be dealt with severely. At a minimum, you will receive a mark of zero for the assignment.

Signed:<u> Alan O'Regan</u>
Date: <u>22/11/2022</u>

# Huffman-Project

## Sources and References
- Icons
  - [Compress Icon](https://www.flaticon.com/authors/ibrandify)
  - [Maximise Icon](https://www.flaticon.com/authors/bharat-icons)

- Code
  - [Tree traversal](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)
  - [Binary Search](https://www.geeksforgeeks.org/binary-search/)
